import 'package:flutter/material.dart';

// ----------------------------------------------------------------------------
// Helper interface
// ----------------------------------------------------------------------------

class Vector2i
{
  int x = 0;
  int y = 0;

  Vector2i.origin(): x = 0, y = 0 {}
  Vector2i(this.x, this.y);

  Vector2i operator +(Vector2i vec) => Vector2i(x + vec.x, y + vec.y);
  Vector2i operator -(Vector2i vec) => Vector2i(x - vec.x, y - vec.y);
}

enum Direction
{
  Left,
  Top,
  Right,
  Bottom
}

Vector2i directionToVector(Direction direction)
{
  switch(direction)
  {
    case Direction.Left: return Vector2i(-1, 0); break;
    case Direction.Top: return Vector2i(0, -1); break;
    case Direction.Right: return Vector2i(1, 0); break;
    case Direction.Bottom: return Vector2i(0, 1); break;        
  }
}

// ----------------------------------------------------------------------------
// Abstractions
// ----------------------------------------------------------------------------

abstract class Renderable
{
  Color getRepresentation();
}

abstract class Playable
{
  void processTapInput(TapDownDetails details);
}


// ----------------------------------------------------------------------------
// Main code
// ----------------------------------------------------------------------------

class Powerup implements Renderable
{
  Color color;
  int bonusSize;
  
  Powerup(this.color, this.bonusSize);
  
  factory Powerup.createInstance(String powerupName)
  {
    if(powerupName.toLowerCase() == "apple")
    {
      return Powerup(Colors.red, 1);
    }
    else if(powerupName.toLowerCase() == "orange")
    {
      return Powerup(Colors.orange, 2);
    }

    assert(false, "Unknown name was given!");
    return Powerup(Colors.black, 0);
  }
  
  Color getRepresentation()
  {
    return color;
  }
}

class SnakePart implements Renderable
{
  Vector2i position;

  SnakePart(this.position);
  
  Color getRepresentation()
  {
    return Colors.green;
  }
}


class Snake implements Playable
{
  List<SnakePart> parts = [];
  Direction currentDirection = Direction.Right;
  Direction nextDirection = Direction.Right;

  Snake()
  {
    SnakePart head = SnakePart(Vector2i.origin());
    parts.add(head);
    nextDirection = currentDirection = Direction.Right;
  }
  
  void processTapInput(TapDownDetails details)
  {
    // TODO: determine nextDirection
  }
  
  void move(GameMap gameMap)
  {
    Vector2i newPosition = gameMap.wrapPosition(parts[0].position + directionToVector(nextDirection));
    for(SnakePart part in parts)
    {
      Vector2i prevPosition = part.position;

      gameMap.renderables[newPosition.y][newPosition.x] = gameMap.renderables[prevPosition.y][prevPosition.x];
      gameMap.renderables[prevPosition.y][prevPosition.x] = null;
      
      part.position = newPosition;
      newPosition = prevPosition;
    }

    currentDirection = nextDirection;
  }
}

class GameMap
{
  // Snake snake;
  List<List<Renderable?>> renderables = <List<Renderable?>>[];

  GameMap(int width, int height)//: //snake = Snake()
  {
    for(var i = 0; i < height; i++)
    {
      renderables.add(<Renderable?>[]);
      renderables[i].length = width;
    }
  }
  
  void processTapInput(BuildContext context, TapDownDetails details)
  {
    
  }
  
  void update()
  {
    
  }
  
  Widget render()
  {
    var tableRows = <TableRow>[];
    for(var row in renderables)
    {
      var tableRowWidgets = <Widget>[];
      for(Renderable? renderable in row)
      {
        tableRowWidgets.add(
          TableCell(
            child: Container(
              color: (renderable == null ? renderable?.getRepresentation() : Colors.blue),
              height: 10,
              width: 10,
            ),
          ),
        );
      }
      
      tableRows.add(
        TableRow(
          children: tableRowWidgets,
        ),
      );
    }

    return Center(child: Container(
      child: Table(
        border: TableBorder.all(),
        children: tableRows,
      ),
      width: 100,
      height: 100
  ));
  }

  Vector2i wrapPosition(Vector2i position)
  {
    Vector2i newPosition = position;
    final width = renderables[0].length;    
    final height = renderables.length;
    
    if(newPosition.x >= width)
    {
      newPosition.x = 0;
    }
    else if(newPosition.x < 0)
    {
      newPosition.x = width - 1;
    }

    if(newPosition.y >= height)
    {
      newPosition.y = 0;
    }
    else if(newPosition.y < 0)
    {
      newPosition.y = height - 1;
    }

    return newPosition;
  }
}
